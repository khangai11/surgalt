# Parallel Binary search algorithm

Ойлгосноо бичье.

Нэг асуултанд binary search ашиглаад хариулах боломжтой үед олон асуултанд нь зэрэг хариулах боломж олгоно. Time complexity нь арай их O(logM * (N+Mα(N)+Q)). α(N) is Inverse of Ackermann function(almost constant)

Жишээ бодлого: https://atcoder.jp/contests/abc394/tasks/abc394_g

хамгийн богино зам нь одоо байгаа газраасаа X болтол доошоо шатаар яваад, зөвхөн X давхруудаар дамжиж яваад очих ёстой байшин дээрээ очоод дээшээ Z давхар болтол өгсөх. Энэ дундаас X-ийн байж болох хамгийн том утгыг нь binary search хийж олно.
Асуулт болгонд Binary search хийвэл амжихгүй учир parallel binary search хийе.

i дахь асуултын хувьд l_i давхраар дамжиж очиж болдог, r_i давхраар дамжиж очиж чаддаггүй мэдэж байгаа үед m_i = (l_i+r_i)/2 давхраар очиж болдог бол l_i = m_i үгүй бол r_i = m_i болгоод update хийгээд явна. 
Асуулт болгоны хувьд доорхи утгыг мэдэж байгаа.
l_i = 1;
r_i = 1e6;
Бүх асуултын хувьд l_i + 1 = r_i болтол үйлдэл хийнэ.

Binary search-ийн давталт болгоны хувьд бүх асуултын m_i үед эхлэлийн цэгээс төгсгөлийн цэг хүртэл очих боломжтой эсэхийг хурдан олохын тулд 
* Хөрш нүднүүдийг 2 талынх нь аль намхан өндрөөр нь sort хийж хадгална.
* UnionFind ашиглаад өндрөөс нь эхлээд join хийгээд явна.
* m_i-аас дээш өндөртэй цэгүүдийг холбосны дараа (a_i,b_i) болон (c_i,d_i) нь холбогдсон эсэхийг шалгаад, l_i болон r_i шинэчилнэ.

Problems:
https://www.spoj.com/problems/METEORS/


https://codeforces.com/blog/entry/45578