# stl functions
|function|Тайлбар|
|---|---|
| abs(x) | x-ийн Absolute утгыг нь буцаана |
| min(x,y) | x,y 2-ийн бага утгыг нь буцаана |
| max(x,y) | x,y 2-ийн их утгыг нь буцаана |
| swap(x,y) | x,y 2-н утгыг нь солино.<br> a=3,b=5 байгаад swap(a,b) хийвэл a=5,b=3 болно |
| __gcd(x,y) | x,y 2-ийн ХИЕХ-ийг буцаана. stl функц биш, GCC compiler-Т байдаг функц. C++17-оос хойшхи version ашиглаж байгаа бол gcd() гэсэн функцийг ашиглах нь зөв. |
| reverse(a,a+n);<br>reverse(a.begin(),a.end()); | int a[]-г урвуулна. a={1,2,3,4} байвал a={4,3,2,1} болно. |
| lower_bound(a,a+n,x);<br>lower_bound(a.begin(),a.end(),x); | a дотроос x-тэй тэнцүү юм уу их тоонуудын хамгийн бага тооны pointer-ийг буцаана. |
| upper_bound(a,a+n,x);<br>upper_bound(a.begin(),a.end(),x) | a дотроос x-ээс их тоонуудын хамгийн бага тооны pointer-ийг буцаана. |
| count(a,a+n,x);<br>count(a.begin(),a.end(),x); | a дотор x тоо хэд байгааг олно. |
| find(a,a+n,x)<br>find(a.begin(),a.end(),x) | a дотроос хамгийн эхэнд байгаа x-ийн pointer-ийг нь буцаана. байхгүй бол &a[n]-ийг буцаана. |
| next_permutation(a,a+n);<br>next_permutation(a.begin(),a.end()); | a-ийн сэлгэмлүүд дундаас а-аас их хамгийн бага сэлгэмлийг а-д байрлуулна. хэрвээ тийм сэлгэмэл олдохгүй бол false, олдвол true буцаана. |
| __builtin_popcount(x) | x-тоог 2тын тооллоор бичихэд хэдэн ширхэг 1 байгааг буцаана. stl функц биш, GCC compiler-Т байдаг функц|
| sort(a,a+n);<br>sort(a.begin(),a.end()); | өгөгдсөн дарааллыг үл буурах байдлаар эрэмбэлнэ. |

# C++ version өөрчлөх
"dev c++" тохируулга хийгээгүй бол c++ 98 version ашигладаг.
dev c++ дээр c++ 11-г ашиглахын тулд тохируулга хийх хэрэгтэй.
Tools->Compiler Options -> Settings tab -> Code generation tab -> Language standard(-std): GNU C++11 болгож өөрчлөнө.

# stl::vector

Динамик(хэмжээг нь өөрчилж болдог) урттай дараалал.

| код | тайлбар |
| --- | --- |
| vector\<int> a; | vector төрлийн хувьсаг а-г зарлана.<br> vector<int> байвал int төрлийн утга хадгалах дараалал үүсгэнэ.<br> vector<double> байвал double төрлийн утга хадгалах дараалал үүсгэнэ.  |
| vector\<long long> a(100);| 100 ширхэг long long-той вектор зарлах |
| a.push_back(x); | а-ийн хамгийн ард нь х-г нэмнэ.<br> а={1,2,3}байх үед нь a.push_back(5); гэвэл a={1,2,3,5} болно. |
| a.pop_back() | а-ийн хамгийн арын элементийг дарааллаас хасна.<br> a={1,2,3} байх үед a.pop_back() гэвэл a={1,2} болно. |
| a[i] | a-ийн эхнээсээ i дахь элемент рүү хандахад ашиглана. array-тай адилхан ашиглаж болно. i-нь 0-ээс эхэлдэг. |
| a.size() | а-д одоо байгаа элементийн тоог буцаана. |
| a.resize(n) | а-ийн хэмжээг n болгоно. Одоогын хэмжээ нь n-ээс их бол эхний n элементийг үлдээгээд бусдыг нь устгана. Одоогын хэмжээ нь n-ээс бага байвал n-ээс default утгатай элементийг нэмж n хэмжээтэй болгоно. |

```cpp
vector<int> a;
a.push_back(5); //[5]
a.push_back(9); //[5,9]
a.push_back(100); //[5,9,100]
a.pop_back();   //[5,9]
a.push_back(3); //[5,9,3]

cout<<a[2]; //3
a[1] = 50;//[5,50,3]

vector<int> b(4);   //[0,0,0,0]
cin>>b[3];//OK
cin>>b[4];//error

vector<int> c = {1,2,5,7,9};

vector<int> d(6,4); //[4,4,4,4,4,4]

//бүх утгаар нь loop хийх амархан арга
for(auto v: c){
    cout<<v<<" ";   //1 2 5 7 9
}

vector<int> a={1,2,4,5};
vector<int> b = {1,3,5,6};
//хамгийн эхний ялгаатай элементийн аль нь бага байна тэр нь бага гэсэн үг.
//эсвэл богинохон урттай нь бага байна.
//a[0]==b[0] харин a[1]<b[1] учраас a нь бага гэсэн үг
//time complexity: O(a.size()+b.size())
if(a<b){
    cout<<"a ni baga";//энэ хэвлэгдэнэ.
} else {
    cout<<"b ni baga";
}
```




# iterator

iterator нь элементийн байрлалыг заасан хувьсагч юм.
begin нь өгөгдлийн(vector, map..) хамгийн эхний элементийн байрлалыг заана. Харин end нь өгөгдлийн хамгийн сүүлийн элементийн байрлал биш түүний арын байрлалыг заадаг.
Жишээ нь векторын хувьд ийм болно.

```
vector<int> a = {1,2,3,4,5,6};
                 |           |
                 begin       end
```
begin нь өгөгдлийн дотор байгаа элементийн байрлалыг заадаг бол end нь өгөгдлийн гадна талын байрлалыг заадаг.

stl-ийн олон функ-д өгөгдлийн эхлэл төгсгөлийн iterator-ийг нь параметр болгож дамжуулдаг.
```cpp
vector<int> a = {1,2,3,4,5,6};
sort(a.begin(),a.end());
auto itr = lower_bound(a.begin(),a.end(),5);
```
iterator-ийн зааж байгаа байрлалд байгаа элемент рүү хандахдаа iterator-ийн урд талд нь * тавьж ханддаг.

```cpp
vector<int> a = {5,5,4};
auto itr = a.begin();
*itr = 6;   //[6,5,4]
itr++;  //дараагын элемент рүү заана.
cout<<*itr;//5

//random access хийж болдог data structure-ийн хувьд
vector<int> a = {1,2,3,4,5,6,7};
auto itr = lower_bound(a.begin(),a.end(),5);
//itr нь 5-ийн байрлалыг зааж байгаа
int val = itr - a.begin();//val = 4
//1-ийн байрлалыг зааж байгааг хасвал 4 гарна.
//5-аас эрс бага тоо 4 ширхэг байна гэсэн үг.
cout<<val;//4
```

```
Бодлого1:
n (n<100) урттай а тоон дараалал өгөгдөнө. Эдгээр тоонуудын ХИЕХ-ийг ол.
Оролт эхний мөрөнд n тоо өгөгдөнө. Дараагын мөрөнд n ширхэг эерэг бүхэл тоо өгөгдөнө.

input:
4
7 14 21 28
output: 7

input1:
10
5 100 200 455 5 25 10005 900 440 1000

input2:
100
18165 11802 2436 13461 27846 1281 29274 24192 14700 22344 3423 10626 4284 882 24780 23856 19551 11151 14553 15435 28014 12495 1680 30828 4410 25599 7077 3633 11634 25095 26544 7455 22470 19719 6888 4158 7245 22722 20916 10983 10122 23814 11718 19845 18249 25074 105 1764 1932 23289 27090 17850 28077 1050 4683 15918 6006 5355 24486 22470 16716 15960 19740 14343 30597 9807 18228 15414 30492 22071 12852 30912 357 20160 31878 4011 10122 14028 25410 29715 20622 22554 19404 28035 32592 24234 22155 28560 6888 3486 3738 6678 16254 24318 23436 29967 22785 16821 6048 15750

input3:
30
17519 9400 9230 2732 6495 5201 8775 24627 629 3407 18131 16191 3463 18620 32484 22342 1788 4339 7351 23976 2703 8023 3699 30967 4433 580 31829 30357 8429 8006
```

```
Бодлого2:
n(n<=8) тоо өгөгдөнө. a = {1,2,3,...,n} гэсэн дарааллын бүх боломжит сэлгэмлийг хэвлэ. Сэлгэмэл болгоныг 1 мөрөнд хэвлэнэ.
input: 3
output:
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1

input1: 2
input2: 5
input3: 8

```

```
Бодлого3:
n ширхэг эерэг бүхэл тоо өгөгдөнө. эдгээр тоонуудыг 2тын тооллоор бичих үед хамгийн олон 1 орсон тоог хэвлэ. Олон хариу байгаа үед тэр дундаас хамгийн том тоог нь хэвлэнэ.
Оролт: эхний мөрөнд n тоо өгөгдөнө. Дараагын мөрөнд n ширхэг эерэг бүхэл тоо өгөгдөнө.
input:
5
1 2 3 4 5
output: 3

input1:
5
32697 23491 29681 11445 11250

input2: 
50
32762 9083 26516 1192 20933 7189 3101 25424 27464 24665 31013 10740 15456 4934 11781 24993 21686 17772 31323 22408 22664 9889 14580 31825 12973 32758 12784 19889 10195 2538 26656 32319 12044 29405 21939 20355 13193 10695 23570 21072 9124 16681 27400 340 28964 32324 8998 27118 26301 26762

input3:
200
18709 5775 23764 3226 2427 29293 19525 9829 12286 7795 30664 27231 4296 30001 2684 26299 4749 20123 6227 19507 7533 17247 9238 27644 28956 14966 18089 20985 9792 29945 23441 20271 24346 3127 22195 2169 27497 5636 10078 23932 25483 25428 19596 15326 32486 3336 32357 12979 10630 17159 4357 23096 7431 4497 29823 25540 182 4304 30242 26107 21747 12976 9979 14661 11738 8945 2970 30847 290 28027 31001 31216 2884 24305 17243 21630 4064 21384 8338 17697 31069 26650 26116 2201 7121 16758 526 32092 7968 24059 22377 8659 21607 9573 23980 17093 31387 10982 11026 28180 13933 21881 19326 32167 16753 25203 2236 20135 5248 30298 2058 30958 4443 12283 24791 6844 28560 29111 4298 3244 28834 21790 28934 4583 8036 31935 4269 22680 7846 14397 6306 24224 19219 11942 7316 3722 13402 769 32056 10433 12684 10022 16341 19712 5317 20691 32518 14347 16911 17659 22716 2461 11651 28001 32130 9889 1202 27750 17669 2980 1859 8991 27603 9099 21213 23979 24163 30337 9799 6596 13654 17716 24525 7059 18172 25665 15078 17609 29210 27628 4373 25067 1514 4117 8717 25069 27492 13416 10008 11267 29628 4307 13753 1972 28716 31293 13712 19248 30451 9077
```


```
Бодлого4:
Эхний мөрөнд n болон q тоо өгөгдөнө. дараагын мөрөнд үл буурах n ширхэг эерэг бүхэл тоо өгөгдөнө. 
Дараагын q мөрөнд нэг нэг эерэг x тоо өгөгдөнө. 
x болгоны хувьд x-ээс бага юм уу тэнцүү тоонуудын тоог ол.(O(q*log(n))-ээр бодоорой.)

input:
8 3
1 1 3 4 5 6 7 8
1
4
8
output:
2
4
8

input1:
200 10
56 129 198 266 334 416 489 510 522 599 647 707 741 793 807 832 838 929 1025 1040 1071 1116 1139 1223 1244 1259 1274 1333 1379 1398 1425 1471 1483 1564 1634 1699 1725 1795 1857 1943 1966 2037 2113 2196 2215 2251 2287 2364 2415 2443 2461 2491 2522 2581 2662 2668 2710 2751 2839 2884 2914 2921 2959 3055 3148 3155 3157 3197 3292 3353 3428 3447 3495 3502 3598 3680 3724 3757 3816 3894 3987 4052 4087 4115 4121 4166 4234 4245 4287 4297 4363 4366 4376 4475 4495 4518 4576 4675 4693 4759 4776 4795 4804 4894 4922 5018 5032 5101 5194 5240 5269 5322 5330 5427 5490 5545 5587 5592 5627 5630 5694 5721 5754 5759 5857 5945 5997 6000 6005 6097 6126 6155 6208 6259 6294 6367 6406 6473 6566 6642 6680 6768 6770 6862 6874 6944 6955 6996 7072 7087 7097 7183 7268 7320 7354 7357 7415 7488 7587 7599 7695 7778 7821 7888 7939 7977 7982 7984 8077 8152 8181 8193 8196 8275 8283 8308 8361 8421 8439 8467 8467 8527 8596 8596 8650 8682 8726 8796 8837 8864 8960 9018 9054 9077 9138 9236 9251 9350 9434 9453
6899
3475
3069
8871
7778
2404
2402
533
1786
2605

input2:
20 20
78 123 128 204 208 287 346 411 424 471 499 547 625 685 728 789 821 903 913 948
367
18
924
778
496
411
105
182
672
122
457
399
505
385
444
106
31
679
422
674
```

```
Бодлого5:
n(n<=1000) ширхэг эерэг бүхэл тоо өгөгдөнө. Эдгээр тоонуудаас боломжит хос болгоны ХИЕХ-ийнх нь хамгийн их утгыг ол.
Эхний мөрөнд n тоо, 2дох мөрөн n ширхэг эерэг бүхэл тоо өгөгдөнө.
input:
5
2 3 6 10 15
output: 5
ХИЕХ(10,15) нь хамгийн том нь

input1:
10
5 100 200 455 5 25 10005 900 440 1000

input2:
100
18165 11802 2436 13461 27846 1281 29274 24192 14700 22344 3423 10626 4284 882 24780 23856 19551 11151 14553 15435 28014 12495 1680 30828 4410 25599 7077 3633 11634 25095 26544 7455 22470 19719 6888 4158 7245 22722 20916 10983 10122 23814 11718 19845 18249 25074 105 1764 1932 23289 27090 17850 28077 1050 4683 15918 6006 5355 24486 22470 16716 15960 19740 14343 30597 9807 18228 15414 30492 22071 12852 30912 357 20160 31878 4011 10122 14028 25410 29715 20622 22554 19404 28035 32592 24234 22155 28560 6888 3486 3738 6678 16254 24318 23436 29967 22785 16821 6048 15750

input3:
30
17519 9400 9230 2732 6495 5201 8775 24627 629 3407 18131 16191 3463 18620 32484 22342 1788 4339 7351 23976 2703 8023 3699 30967 4433 580 31829 30357 8429 8006
```

# stl::string
string нь vector\<char\> л гэсэн үг. vector-ийн фунцуудыг бүгдийг нь ашиглаж болно.

| код | тайлбар |
| --- | --- |
| string s; | string төрлийн s хувьсагч зарлах |
| cin>>s; | гараас string төрлийн хувьсагч унших |
| cout<<s; | string төрлийн хувьсагчыг хэвлэх |
| string a = "hello";<br>string b=" world";<br>string c = a+b; | string-үүдийг залгаж болдог.O(size) |
| s.substr(start,size); | s-ийн start индексээс эхлэн size хэмжээтэй string-ийг буцаана. |


# stl::queue

Queue нь хамгийн эхэнд хийсэн элементээ хамгийн эхэнд нь авж болдог өгөгдлийн бүтэц. Оочирт зогсож байгаа хүмүүсийг төсөөлөх юм бол ойлгоход илүү амар санагдах байх.
![Alt](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726165642/Queue-Data-structure1.png)

Хамгийн ард талд нь шинээр элемент нэмж, хамгийн урд талын элементийг нь авч болно гэсэн үг.

| код | тайлбар |
| --- | --- |
| queue<long long> b; | b нэртэй long long төрлийн хувьсагчууд хадгалах queue зарлах |
| b.push(x) | b-ийн хамгийн ард нь х-г нэмнэ. |
| b.pop() | b-ийн хамгийн урд талын элементийг авч хаяна |
| b.front() | b-ийн хамгийн урд талын элементийг буцаана. Тэр элемент урд талдаа байсаар л байна. |
|b.size() | b дотор хичнээн элемент байгааг буцаана. |
| b.empty() | b дотор элемент байхгүй бол true, байвал false буцаана. |
| b.clear() | b-ийн доторхи бүх элементийг устгана. |
|  |  |

queue-ийн push,pop,front зэрэг үйлдлүүдийн time complexity нь O(1).

```cpp
queue<long long> a;
a.push(3);  //{3}
a.push(10); //{3,10}
long long b = a.front();    //b=3 a={3,10}
a.push(1);  //a={3,10,1}
a.pop();    //a={10,1}
if(a.empty()){  //a dotor 2 element baigaa uchir false butsaana.
    cout<<"a ni hooson bna.\n";     //ene hevlegdehgui 
}
a.push(400);    //a={10,1,400}

```

# stl::deque
deque = double ended queue
queue нь зөвхөн хамгийн ард нь элемент нэмж, хамгийн урд талаас нь авч болдог бол deque нь аль ч талаас нь нэмж, аль ч талаас элемент авах боломжтой өгөгдлийн бүтэц.

| код | тайлбар |
| --- | --- |
| deque<long long> a; | a нэртэй long long төрлийн хувьсагчууд хадгалах deque зарлах |
| a.push_back(x) | a-ийн хамгийн ард нь х-г нэмнэ. |
| a.push_front(x) | a-ийн хамгийн урд нь х-г нэмнэ. |
| b.pop_back() | b-ийн хамгийн ард талын элементийг авч хаяна |
| b.pop_front() | b-ийн хамгийн урд талын элементийг авч хаяна |
| b.front() | b-ийн хамгийн урд талын элементийг буцаана.  |
| b.back() | b-ийн хамгийн ард талын элементийг буцаана. |
|b.size() | b дотор хичнээн элемент байгааг буцаана. |
| b.empty() | b дотор элемент байхгүй бол true, байвал false буцаана. |
| b.clear() | b-ийн доторхи бүх элементийг устгана. |

# stl::stack

stack нь хамгийн сүүлд хийсэн элементээ хамгийн эхэнд нь авж болдог өгөгдлийн бүтэц.
![Alt](https://cdn.programiz.com/sites/tutorial2program/files/stack.png)

| код | тайлбар |
| --- | --- |
| stack<int> s; | s нэртэй int төрлийн хувьсагчууд хадгалах stack зарлах |
| s.push(x) | s-ийн дээд талд нь х-г нэмнэ. |
| s.pop() | s-ийн хамгийн дээд талын элементийг авч хаяна |
| b.top() | b-ийн хамгийн дээд талын элементийг буцаана.  |
|b.size() | b дотор хичнээн элемент байгааг буцаана. |
| b.empty() | b дотор элемент байхгүй бол true, байвал false буцаана. |
| b.clear() | b-ийн доторхи бүх элементийг устгана. |

stack гэсэн ойлголтыг програм дээр их ашигладаг боловч vector ашиглаад stack-ийн бүх үйлдлийг нь хийж чадах учир минйи хувьд дандаа vector ашиглачихдаг.
```cpp
stack<int> s;
s.push(4); //s={4}
s.push(10); //s={4,10};
s.push(35); //s={4,10,35}
int b = s.top();    //b=35 s={4,10,35}
s.pop();    // s = {4,10};
s.pop();    //s={4}
int c = s.size();   //c=1
```

```
Бодлого6:
Зөвхөн '(' болон ')'-ээс бүрдсэн нэг мөрөнд string өгөгдөнө.
'('болон ')'-уудын хооронд + тэмдэг болон тоо тавихад зөв математик тэгшитгэл үүсдэг бол зөв string гэж нэрлэе.
Өгөгдсөн string нь зөв string бол YES, биш бол NO гэж хэвлэ.
input:(())
output:YES

input: ()()()()
output:YES

input: ())
output:NO

input: ((())((())()))(((((())))))
output:YES

input: (((((())())(((()(()))(())))())())))
output:NO
```


```
Бодлого7:
n ширхэг эерэг тоо өгөгдөнө. Дарааллан орсон ижил тоо байхгүй болгохын тулд дарааллан орсон ижил тоонуудаас зөвхөн 1-ийг нь л үлдээж бусдыг нь устгах үйлдэл хийв. Үлдсэн тоон дарааллыг хэвлэнэ үү.
Гаргахдаа эхний мөрөнд нийт үлдсэн тооны тоог, дараагын мөрөнд үлдсэн тоонуудыг дарааллын дагуу гаргана уу.
input:
5
1 1 2 2 2
output:
2
1 2

input: 
5
1 3 3 1 3
output:
4
1 3 1 3

input: 
7
1 2 3 4 5 6 7
output:
7
1 2 3 4 5 6 7

input: 20
99 99 101 101 101 1 2 3 4 5 5 5 12 14 19 19 20 48 39 39
output:
13
99 101 1 2 3 4 5 12 14 19 20 48 39

input:
30
1 1 1 1 1 2 2 2 2 3 3 3 5 5 5 5 5 8 8 8 21 21 21 22 22 22 22 23 23 23
output:
8
1 2 3 5 8 21 22 23
```


# stl::pair
2 төрлийн хувьсагчыг нэг болгож хадгалдаг төрөл.
pair-ийн эхний хувьсагч руу хандахдаа first, 2 дох хувьсагч руу хандахдаа second гэж хандана.

| код | тайлбар |
| --- | --- |
| pair<int,char> a; | Эхний хувьсагчын төрөл нь int, 2 дох хувьсагчын төрөл нь char гэвэл дараахь байдлаар зарлана. |
| a = make_pair(10,'z'); | a гэдэг хувьсагчид эхний хувьсагчид 10 гэсэн утга, 2дох хувьсагчид 'z' гэсэн утга онооно. |
| int c = a.first; | pair-ийн эхний хувьсагч руу хандахад first гэж хандана. |
| char ch = a.second; | pair-ийн 2дох хувьсагч руу хандахад second гэж хандана. |
| pair<int,int> a,b;<br>a = make_pair(4,5);<br>b=make_pair<8,10>;<br>if(a<b) cout<<"a baga"<br> else cout<<"b baga"; | харьцуулахдаа эхний элементийг нь харьцуулна. Тэнцүү байвал 2дох элементийг нь харьцуулна. |
 ```cpp
 pair<int, string> a;
 pair<string, long long> b;
 vector<pair<string,int>> c;
 c.push_back(make_pair("hello",4));
 c.push_back(make_pair("world",10));
 for(auto v:c){
    cout<<v.first<<" "<<v.second<<"\n";
 }
 //hello 4
 //world 10

 pair<int,pair<int,int> > d;
 d = make_pair(10,make_pair(20,30));
 ```

# stl::tuple

2-оос олон хувьсагчийг нэг дор нэг хувьсагчид хадгалдаг төрөл.pair нь зөвхөн 2 хувьсагч хадгалдаг бол tuple-д 2-оос олон хувьсагч хадгалж болдог.

| код | тайлбар |
| --- | --- |
| tuple<int,int,string> a; | int,int,string төрлийн 3 хувьсагч хадгалах tuple зарлах |
| a = make_tuple(1,2,"hi"); | tuple хувьсагчид утга оноох |
| cout<<get<0>(a);<br>cout<<get<2>(a); | утгыг нь уншихдаа get<index> гэж ашиглана. |

# stl::set,multiset
Set,multiset,map нь элементүүдийг хадгалах өгөгдлийн бүтэц. Элемент нэмэх, хайх,устгах үйлдэл хийж болдог. Дотроо balanced binary search tree гэх өгөгдлийн бүтэц ашиглаж нэмэх,хайх,устгах үйлдлүүд нь тус бүр O(log(N))-д ажилладаг.(N нь set дотор байгаа элементийн тоо).

set - Адилхан утгатай элемент бол зөвхөн нэг л элемент хадгална.
multiset - Адилхан утгатай элемент олонги хадгалж болдог өгөгдлийн бүтэц.

| код | тайлбар |
| --- | --- |
| set<int> a; | int төрлийн элемент хадгалах set зарлах |
| a.insert(5); | a-д x-ийн утгыг нэмнэ. Мultiset-ийн хувьд а дотор 5 байвал дахиж нэмэгдэнэ, set-ийн хувьд 5 өмнө нь байсан бол нэмэгдэхгүй. |
| a.erase(5); | a-д 5 гэсэн утга байвал устгана. |
| a.erase(y); | y нь iterator бол тухайн зааж байгаа элементийг устгана. |
| a.lower_bound(x); | vector-ийн lower_bound-тай адилхан. х-тэй тэнцүү эсвэл их элементүүдээс хамгийн бага элементийг зааж байгаа iterator-ийг нь буцаана. |
| a.upper_bound(x); | vector-ийн upper_bound-тай адилхан. х-ээс их элементүүдээс хамгийн бага элементийг зааж байгаа iterator-ийг нь буцаана. |
| a.clear(); | a-г хоосон болгоно. |


# stl::priority_queue
# stl::map



# stl::bitset
