# stl::queue

Queue нь хамгийн эхэнд хийсэн элементээ хамгийн эхэнд нь авж болдог өгөгдлийн бүтэц. Оочирт зогсож байгаа хүмүүсийг төсөөлөх юм бол ойлгоход илүү амар санагдах байх.
![Alt](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726165642/Queue-Data-structure1.png)

Хамгийн ард талд нь шинээр элемент нэмж, хамгийн урд талын элементийг нь авч болно гэсэн үг.

| код | тайлбар | Time complexity |
| --- | --- | --- |
| queue\<long long\> b; | b нэртэй long long төрлийн хувьсагчууд хадгалах queue зарлах | O(1) |
| b.push(x) | b-ийн хамгийн ард нь х-г нэмнэ. | O(1) |
| b.pop() | b-ийн хамгийн урд талын элементийг авч хаяна | O(1) |
| b.front() | b-ийн хамгийн урд талын элементийг буцаана. Тэр элемент урд талдаа байсаар л байна. | O(1) | 
|b.size() | b дотор хичнээн элемент байгааг буцаана. | O(1) |
| b.empty() | b дотор элемент байхгүй бол true, байвал false буцаана. | O(1) |
| b.clear() | b-ийн доторхи бүх элементийг устгана. | O(1) |

queue-ийн push,pop,front зэрэг үйлдлүүдийн time complexity нь O(1).

```cpp
queue<long long> a;
a.push(3);  //{3}
a.push(10); //{3,10}
long long b = a.front();    //b=3 a={3,10}
a.push(1);  //a={3,10,1}
a.pop();    //a={10,1}
if(a.empty()){  //a dotor 2 element baigaa uchir false butsaana.
    cout<<"a ni hooson bna.\n";     //ene hevlegdehgui 
}
a.push(400);    //a={10,1,400}

```

# stl::deque
deque = double ended queue
queue нь зөвхөн хамгийн ард нь элемент нэмж, хамгийн урд талаас нь авч болдог бол deque нь аль ч талаас нь нэмж, аль ч талаас элемент авах боломжтой өгөгдлийн бүтэц.

| код | тайлбар |
| --- | --- |
| deque\<long long\> a; | a нэртэй long long төрлийн хувьсагчууд хадгалах deque зарлах |
| a.push_back(x) | a-ийн хамгийн ард нь х-г нэмнэ. |
| a.push_front(x) | a-ийн хамгийн урд нь х-г нэмнэ. |
| b.pop_back() | b-ийн хамгийн ард талын элементийг авч хаяна |
| b.pop_front() | b-ийн хамгийн урд талын элементийг авч хаяна |
| b.front() | b-ийн хамгийн урд талын элементийг буцаана.  |
| b.back() | b-ийн хамгийн ард талын элементийг буцаана. |
|b.size() | b дотор хичнээн элемент байгааг буцаана. |
| b.empty() | b дотор элемент байхгүй бол true, байвал false буцаана. |
| b.clear() | b-ийн доторхи бүх элементийг устгана. |

<br>
Дасгал1.
<br>
Эхлээд N тоо үүний дараа A<sub>1</sub>, A<sub>2</sub>,A<sub>3</sub>,...,A<sub>N</sub> тоонууд өгөгдөнө.
Дараагын мөрөнд M тоо өгөгдөнө.
A<sub>1</sub>, A<sub>2</sub>,A<sub>3</sub>,...,A<sub>M</sub> тоонуудыг дарааллын дагуу хэвлэ. (vector,array ашиглахгүй, queue ашиглаж бодно уу.)

input:
10
1 2 3 4 5 6 7 8 9 10
6

<br>
Дасгал2.
<br>
N сурагч тойргоор жагсаж байгаа. Сурагчдыг 1,2,3...,N гэж дугаарлая.
1-р сурагчаас эхлээд тоолж эхлээд, 5 дахь сурагчдыг тойргоос гаргаад байв. хамгийн сүүлд ямар сурагч тойрогт ганцаараа үлдэх вэ? (1<=N<=10^6)
<br>
оролт: 10

гаралт: 3

<br><br>

оролт: 2345

гаралт: 1377


<br>

[Problem_1](https://atcoder.jp/contests/abc247/tasks/abc247_d)
<br>

[Problem 2](https://atcoder.jp/contests/abc379/tasks/abc379_d)
<br>

[Problem 3](https://atcoder.jp/contests/abc005/tasks/abc005_3)
```
Тakahashi тaкoяки-г ямар дарааллаар зарах вэ гэж бодож байв. Учир нь, урьдчилан хийж хадгалсан тaкoяки амтгүй гэдгийг тэр мэдэж байсан тул ийм тaкoяки-г зарахыг хүсэхгүй байлаа. Гэхдээ зөвхөн шинэхэн тaкoяки-г зараад байвал зарагдах тaкoяки-ийн тоо багасна.

Мөн үйлчлүүлэгчдийг удаан хүлээлгэвэл, аажмаар үйлчлүүлэгчид явж магадгүй гэж Такahashi үзжээ.
Тиймээс тэрээр T секундийн дотор хийгдсэн тaкoяки-г л зарсаар байхад бүх үйлчлүүлэгчдэд хүрэлцэх эсэхийг шалгахаар шийдсэн байна.

Тaкoяки-нууд нь
A1, A2, …, An секундийн дараа бэлэн болно.

Үйлчлүүлэгчид нь
B1, B2, …, Bm секундийн дараа ирнэ.

Нэг үйлчлүүлэгчид 1 ширхэг тacoяки зарна.
Хэрэв бүх үйлчлүүлэгчдэд тacoяки зарж чадвал yes, эс чадвал no гэж хэвлэнэ.

Оролт (Input)

Оролт дараах хэлбэртэйгээр стандарт оролтоор өгөгдөнө.

T
N
A1 A2 ... An
M
B1 B2 ... Bm


1-р мөр:
T — хэдэн секундийн дотор хийгдсэн тaкoяки-г зарахыг илэрхийлэх бүхэл тоо
(1 ≤ T ≤ 100)

2-р мөр:
N — Такahashi-гийн хийх тaкoяки-ийн нийт тоо
(1 ≤ N ≤ 100)

3-р мөр:
Aᵢ — тaкoяки бүр хэдэн секундийн дараа бэлэн болохыг илэрхийлэх бүхэл тоонууд
(1 ≤ Aᵢ ≤ 100, A₁ ≤ A₂ ≤ … ≤ Aₙ)

4-р мөр:
M — ирэх үйлчлүүлэгчдийн тоо
(1 ≤ M ≤ 100)

5-р мөр:
Bᵢ — үйлчлүүлэгч бүр хэдэн секундийн дараа ирэхийг илэрхийлэх бүхэл тоонууд
(1 ≤ Bᵢ ≤ 100, B₁ ≤ B₂ ≤ … ≤ Bₘ)

Гаралт (Output)

Хэрэв бүх үйлчлүүлэгчид ирэнгүүт нь тохирох тaкoяки-г зарж чадвал yes,
эс чадвал no гэж хэвлэнэ.

Гаралтын төгсгөлд шинэ мөр оруулна.
```

<br>

[Problem 4](https://atcoder.jp/contests/abc216/tasks/abc216_d)
